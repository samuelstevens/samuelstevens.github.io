<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="stylesheet" href="/css/site.css" />

  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <meta charset="utf-8" />
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <title>Optimizing Python Code with <code>cProfile</code> and <code>ctypes</code></title>
</head>

<body>
  <main>
    <header>
      <h1>Behold, My Stuff</h1>
      [<a href="/">Home</a>]
      <!-- [<a href="/blog">Blog</a>] -->
      [<a href="/writing">Writing</a>]
      [<a href="/resume.pdf">Resume</a>]
      [<a href="mailto:samuel.robert.stevens@gmail.com">Email</a>]
      [<a href="https://github.com/samuelstevens">GitHub</a>]

    </header>
    <article class="column content">
<!-- Must be unindented to prevent code indentation being broken -->
<h1 id="optimizing-python-code-with-cprofile-and-ctypes">Optimizing Python Code with <code>cProfile</code> and <code>ctypes</code></h1>
<p>Python is an interpreted language, which typically makes it slower than compiled languages like C/C++, Java, Rust, or Go. However, there are so many packages available for Python that it still makes sense to use it for ML and other problems with large amounts of data.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li><p><a href="#cprofile">cProfile</a></p></li>
<li><p><a href="#snakeviz">SnakeViz</a></p></li>
<li><p><a href="#ctypes"><code>ctypes</code></a></p></li>
<li><p><a href="#pypy">Extra Credit: PyPy</a></p></li>
</ol>
<h2 id="basic-optimizations">Basic Optimizations</h2>
<h3 id="built-in-data-structures">Built-in Data Structures</h3>
<p>The built-in data structures in Python like <code>set</code> and <code>dict</code> are written in C. They are much faster than writing your own data structures as Python classes. Other data structures besides the standard <code>set</code>, <code>dict</code>, <code>list</code>, and <code>tuple</code> are documented in the <a href="https://docs.python.org/dev/library/collections.html#module-collections"><code>collections</code> module</a>.</p>
<h3 id="list-comprehensions">List Comprehensions</h3>
<p>Rather than appending to a list, use list comprehensions.</p>
<pre class="python3"><code>mapped = [myfunc(value) in originallist]</code></pre>
<h2 id="cprofile">cProfile</h2>
<p>Once youve exhausted the above options, profiling your code can show where your code is slow. <code>cProfile</code> is a module built exactly for that. It can be run as a command-line module, or used in your source code to pinpoint a specific function.</p>
<h3 id="from-the-commmand-line">From the Commmand Line</h3>
<p>Run your program as you normally would, but wrap it in <a href="https://docs.python.org/3/library/profile.html#module-cProfile"><code>cProfile</code></a>:</p>
<ol type="1">
<li>Outputs all function calls sorted by internal time.</li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>    <span class="ex">python</span> -m cProfile -s tottime writing.py</span></code></pre></div>
<ol start="2" type="1">
<li>Outputs all function calls sorted by internal time and sends it to <code>writing.txt</code> for later inspection.</li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a>    <span class="ex">python</span> -m cProfile -s tottime writing.py <span class="op">&gt;</span> writing.txt</span></code></pre></div>
<ol start="3" type="1">
<li>Outputs all function calls to <code>writing.prof</code> to be used by another tool later on.</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a>    <span class="ex">python</span> -m cProfile -o writing.prof writing.py</span></code></pre></div>
<h3 id="as-a-module">As a Module</h3>
<p>Additionally, <code>cProfile</code> can be used from inside your source code like so:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>cProfile.run(<span class="st">&quot;eval(arg1, arg2)&quot;</span>, sort<span class="op">=</span><span class="st">&#39;tottime&#39;</span>, filename<span class="op">=</span><span class="st">&#39;eval.prof&#39;</span>)</span></code></pre></div>
<p>The only downside of this is that the first argument is a string that is evaluated by <code>cProfile</code> instead of passing a function and some arguments. Other than that, it works in exactly the same manner.</p>
<p>Regardless of how you use it, the output from these <code>cProfile</code> tools is <em>loooong</em>. It can be read, but its often easier to use it in another tool. Python has support for this with the <a href="https://docs.python.org/3/library/profile.html#pstats.Stats"><code>pstats.Stats</code></a> class.</p>
<h2 id="snakeviz">SnakeViz</h2>
<p><a href="https://jiffyclub.github.io/snakeviz/">SnakeViz</a> is a small open-source tool that was recently very valuable to visualizing profiling data. It presents a graph that shows a breakdown by time per function, and allows you to drill down into what causes the length of each function:</p>
<figure>
<img src="/images/python/snakeviz-icicle.png" alt="" /><figcaption>Icicle graph from SnakeViz</figcaption>
</figure>
<p>From here, you can see what functions take the most time, and what causes each function to take so long. If you can further optimize from here (removing things from loops, using list comprehensions, etc., do so now).</p>
<h2 id="ctypes"><code>ctypes</code></h2>
<p><a href="https://docs.python.org/3/library/ctypes.html"><code>ctypes</code></a> is a module that allows you to communicate with C code from your Python code without using <code>subprocess</code> or similar modules to run another process from the CLI.</p>
<p>There are two parts: compiling your C` code to be loaded as a shared object, and setting up the data structures in your Python code to map to C-types.</p>
<p>Below, I show two structs that are used in my C source code.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">struct</span> Sequence</span>
<span id="cb6-2"><a href="#cb6-2"></a>{</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="dt">char</span> **items;</span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="dt">int</span> length;</span>
<span id="cb6-5"><a href="#cb6-5"></a>};</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">struct</span> Cell</span>
<span id="cb6-8"><a href="#cb6-8"></a>{</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="dt">int</span> index;</span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="dt">int</span> length;</span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="kw">struct</span> Cell *prev;</span>
<span id="cb6-12"><a href="#cb6-12"></a>};</span></code></pre></div>
<p>Here, you see the Python translation of the structs.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">import</span> ctypes</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">class</span> SEQUENCE(ctypes.Structure):</span>
<span id="cb7-3"><a href="#cb7-3"></a>    _fields_ <span class="op">=</span> [(<span class="st">&#39;items&#39;</span>, ctypes.POINTER(ctypes.c_char_p)),</span>
<span id="cb7-4"><a href="#cb7-4"></a>                (<span class="st">&#39;length&#39;</span>, ctypes.c_int)]</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">class</span> CELL(ctypes.Structure):</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="cf">pass</span></span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>CELL._fields_ <span class="op">=</span> [(<span class="st">&#39;index&#39;</span>, ctypes.c_int), (<span class="st">&#39;length&#39;</span>, ctypes.c_int),</span>
<span id="cb7-10"><a href="#cb7-10"></a>                 (<span class="st">&#39;prev&#39;</span>, ctypes.POINTER(CELL))]</span></code></pre></div>
<p>Some notes:</p>
<ul>
<li>All structs are <code>class</code>es that inherit from <code>ctypes.Structure</code>.</li>
<li>The only field is <code>_fields_</code>, which is a list of tuples. Each tuple is <code>(&lt;variable-name&gt;, &lt;ctypes.TYPE&gt;)</code>.</li>
<li><code>ctypes</code> has types like <code>c_char</code> (<code>char</code>), and <code>c_char_p</code> (<code>*char</code>).</li>
<li><code>ctypes</code> also includes <code>POINTER()</code> which creates a pointer type from any type passed to it.</li>
<li>If you have a recursive definition like in <code>CELL</code>, you must <code>pass</code> the initial declaration and then add the <code>_fields_</code> fields to reference itself later.</li>
<li>Since I didn&#x2019;t use <code>CELL</code> in my Python code, I didn&#x2019;t need to write this struct out, but it has a an interesting feature in the recursive field.</li>
</ul>
<p>Additionally, you&#x2019;ll want some code to convert your Python types to your new C structs. Finally, you can use your new C function to speed up your Python code.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">def</span> list_to_SEQUENCE(strlist: List[<span class="bu">str</span>]) <span class="op">-&gt;</span> SEQUENCE:</span>
<span id="cb8-2"><a href="#cb8-2"></a>    bytelist <span class="op">=</span> [<span class="bu">bytes</span>(s, <span class="st">&#39;utf-8&#39;</span>) <span class="cf">for</span> s <span class="kw">in</span> strlist]</span>
<span id="cb8-3"><a href="#cb8-3"></a>    arr <span class="op">=</span> (ctypes.c_char_p <span class="op">*</span> <span class="bu">len</span>(bytelist))()</span>
<span id="cb8-4"><a href="#cb8-4"></a>    arr[:] <span class="op">=</span> bytelist</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="cf">return</span> SEQUENCE(arr, <span class="bu">len</span>(bytelist))</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a>seq1 <span class="op">=</span> list_to_SEQUENCE(s1)</span>
<span id="cb8-8"><a href="#cb8-8"></a>seq2 <span class="op">=</span> list_to_SEQUENCE(s2)</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a>lcsmodule <span class="op">=</span> ctypes.cdll.LoadLibrary(<span class="st">&#39;lcsmodule/lcs.so&#39;</span>)</span>
<span id="cb8-11"><a href="#cb8-11"></a>lcsmodule.lcs.restype <span class="op">=</span> ctypes.POINTER(SEQUENCE)</span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="co"># struct Sequence *lcs(struct Sequence *s1, struct Sequence *s2)</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>common <span class="op">=</span> lcsmodule.lcs(ctypes.byref(seq1), ctypes.byref(seq2))[<span class="dv">0</span>]</span>
<span id="cb8-15"><a href="#cb8-15"></a></span>
<span id="cb8-16"><a href="#cb8-16"></a>ret <span class="op">=</span> []</span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(common.length):</span>
<span id="cb8-19"><a href="#cb8-19"></a>    ret.append(common.items[i].decode(<span class="st">&#39;utf-8&#39;</span>))</span>
<span id="cb8-20"><a href="#cb8-20"></a>lcsmodule.freeSequence(common)</span></code></pre></div>
<p>More notes:</p>
<ul>
<li><code>**char</code> (a list of strings) maps directly to a list of bytes in Python.</li>
<li><code>lcs.c</code> has a function <code>lcs()</code> with the signature: <code>struct Sequence *lcs(struct Sequence *s1, struct Sequence *s2)</code>. To get the return type set up, I use <code>lcsmodule.lcs.restype = ctypes.POINTER(SEQUENCE)</code>.</li>
<li>To make a call with the reference to the <code>struct Sequence</code>, I use <code>ctypes.byref()</code> which returns a &#x201C;light-weight pointer&#x201D; to your object (faster than <code>ctypes.POINTER()</code>).</li>
<li><code>common.items</code> is a list of bytes, so they are decoded to get <code>ret</code> to be a list of <code>str</code>.</li>
<li><code>lcsmodule.freeSequence(common)</code> simply frees the memory associated with <code>common</code>. This is <strong>critical</strong>, because it will not be collect by the garbage collector (AFAIK).</li>
</ul>
<p>Optimized Python code: code that you wrote in C and wrote a wrapper for in Python.</p>
<h2 id="extra-credit-pypy">Extra Credit: PyPy</h2>
<blockquote>
<p>NOTE: I&#x2019;ve never used PyPy personally.</p>
</blockquote>
<p>One simple optimization is simply to run your programs in the <a href="https://www.pypy.org/">PyPy</a> runtime, which includes a just-in-time (JIT) compiler which will speed your loops by compiling them into native code when they run many times.</p>
<p>Please <a href="mailto:samuel.robert.stevens@gmail.com">email me</a> if you have any comments or want to discuss further.</p>
      <hr />
      [<a href="https://www.youtube.com/watch?v=SHbS9tYFpcQ">Relevant link</a>]
      <p>Sam Stevens, 2019</p>
      <p>
        <a href="https://github.com/samuelstevens/personal-website">Source</a>
      </p>
    </article>
  </main>
  <script src="/js/instantclick.min.js" data-no-instant></script>
  <script data-no-instant>
    InstantClick.init();
  </script>
  <style>
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</body>

</html>