<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="stylesheet" href="/css/site.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <meta charset="utf-8" />
  <meta name="description" content="Why I can&#x2019;t decide whether to learn
more languages." />
  <meta name="keywords" content="languages, programming
languages, go, typescript, python, javascript, java, lisp, haskell, c, elm, erlang, rust" />
  <title>Behold: Programming Languages</title>
  
</head>

<body>
  <aside>
    <div id="sidebar">
      <img src="/images/me.jpeg" />
      <p>Sam Stevens</p>
    </div>
  </aside>
  <main>
    <header>
      <h1>Behold, My Stuff</h1>
      <p>
        [<a href="/">Home</a>]
        [<a href="/writing">Writing</a>]
        [<a href="/cv.pdf">CV</a>]
        [<a href="https://github.com/samuelstevens">GitHub</a>]
        [<a href="mailto:samuel.robert.stevens@gmail.com">Email</a>]
      </p>
    </header>
    <article>
      <!-- Must be unindented to prevent code indentation being broken -->
<h1 id="programming-languages">Programming Languages</h1>
<p><em>Alternatively, am I a <a
href="http://www.paulgraham.com/avg.html">Blub</a> programmer?</em></p>
<p>I&#x2019;ve been reading about programming languages a lot. For a while I
thought a new language would solve all of my problems. If I just learn
Lisp like Paul Graham <a
href="http://www.paulgraham.com/iflisp.html">says</a>, I&#x2019;ll never need
another language. If I just learn Haskell, bugs will disappear. If I
just learn <a href="https://elm-lang.org/">Elm</a>, web apps will just
work. And so on. Over and over again, I would get halfway through a
beginner tutorial, need to write some real code for a problem, and use
Python or JavaScript.</p>
<p>Then I read a lot of articles that said that programming languages
and new technology really don&#x2019;t matter: Dan McKinley&#x2019;s <a
href="https://mcfunley.com/choose-boring-technology">Choose Boring
Technology</a> is one of the best examples of this. So I stopped trying
to learn Lisp and Haskell and Elm and focused on old tech that was
proven to work in production (Lisp technically is old tech).</p>
<p>So where does that leave me? With my personal ranking of languages,
of course.</p>
<h2 id="the-list">The List</h2>
<p>When considering a new language, where does it fit? If it&#x2019;s above
everything else in your list, it&#x2019;s probably worth learning. Here&#x2019;s my
list:</p>
<ol type="1">
<li><p><a href="#python">Python 3</a> - ubiquitous, powerful, huge
community, support system and ecosystem.</p></li>
<li><p><a href="#elm">Elm</a> - strongly typed, purely functional,
exclusively designed for web apps.</p></li>
<li><p><a href="#rust">Rust</a> - statically typed, memory safety
without a garbage collector, has a reputation as being difficult to
use.</p></li>
<li><p><a href="#go">Go</a> - strongly typed, garbage collector, cooler
than Java, minimal syntax to learn.</p></li>
<li><p><a href="#typescript">TypeScript</a> - strongly typed, works for
web apps, easy to pick up if you understand JavaScript.</p></li>
<li><p><a href="#c">C</a> - having to think about every line forces
efficient code.</p></li>
<li><p><a href="#javascript">JavaScript</a> - amazing package options,
enormous ecosystem, functional programming concepts.</p></li>
<li><p><a href="#java">Java</a> - it works everywhere.</p></li>
<li><p><a href="c++">C++</a> - it&#x2019;s fast, I guess?</p></li>
</ol>
<blockquote>
<p>Everything below Rust (#3), I don&#x2019;t ever use unless I have to. I use
Python in place of Go or Java, Elm in place of TypeScript or JavaScript,
and Rust in place of C or C++. Basically, the rankings below Rust are
irrelevant.</p>
</blockquote>
<h1 id="languages-i-use-for-new-projects">Languages I use for new
projects</h1>
<p>Python, Elm and Rust are the default language I choose for general
programming, web apps and high-performance computing, respectively.
Unless there is a goal besides &#x201C;solve problems and move on,&#x201D; or there&#x2019;s
a compelling reason to use a different language, I choose Python, Elm
and Rust everytime.</p>
<h2 id="python-3">1. Python 3</h2>
<p>Python was technically a scripting language. Technically. The only
problem is that scripts tend to grow until they&#x2019;re unmaintainable (case
in point: the bash scripts I use to build this website are getting
pretty bad). Python sort of did the same thing and grew, except it
turned into a fantastic general-purpose server-side language for
scripting, data analysis, scientific computing, web applications, and
algorithm interviews. Python&#x2019;s success is arguably because of its
fantastic front-end design (syntax, general semantics), the simple C
FFI, and the monolith of a standard library (<a
href="https://docs.python.org/3.9/library/heapq.html#module-heapq">heapq</a>,
<a
href="https://docs.python.org/3.9/library/bisect.html#module-bisect">bisect</a>
and <a
href="https://docs.python.org/3.9/library/shlex.html#module-shlex">shlex</a>
are some of favorite unknown but highly useful modules <em>in the
standard library</em>). The C FFI helped the scientific computing
ecosystem grow, and packages like <a href="https://numpy.org/">NumPy</a>
and <a href="https://jupyter.org/">Jupyter</a> make Python a daily
driver for all of my research work.</p>
<p>Past the scientific computing, Python&#x2019;s tooling is also pretty
good:</p>
<ol type="1">
<li><a href="https://mypy.readthedocs.io/en/stable/index.html">MyPy</a>
and the <a
href="https://docs.python.org/3/library/typing.html"><code>typing</code>
module</a> turn Python into a pretty nice statically-typed language. Use
<code>--strict</code>.</li>
<li>Virtual environments work well, especially with <code>pyenv</code>
to handle versions of Python. I use a <a
href="https://github.com/samuelstevens/dotfiles/blob/main/bashrc#L55-L72">small
function</a> to handle making and activating virtual environments.</li>
<li><a href="https://github.com/psf/black">Black</a> is a great code
formatter. Fast, opinionated, hardly any set-up.</li>
<li><a href="https://pycqa.github.io/isort/"><code>isort</code></a>
sorts your imports. Also fast and very useful.</li>
<li><a href="https://flake8.pycqa.org/en/latest/">Flake8</a> is a nice
linter for unused imports (and other stuff that I&#x2019;m comletely forgetting
about).</li>
</ol>
<p>When you run into performance issues, it&#x2019;s <a
href="https://samuelstevens.me/writing/optimizing-python-code-with-ctypes">pretty</a>
<a href="https://github.com/PyO3/maturin">easy</a> to rewrite your slow
function in a compiled language and efficiently call it from Python.</p>
<blockquote>
<p>I&#x2019;m going to write an updated version of my <a
href="https://samuelstevens.me/writing/optimizing-python-code-with-ctypes">ctypes</a>
guide for Rust soon. Rust is awesome!</p>
</blockquote>
<p>Overall, Python is a great blend of simplicity, power, and
flexibility. The syntax is very simple, functional programming is <a
href="/writing/lisp#emphasis-on-functional-programming">well
supported</a>, the FFI makes it easy to write highly-optimized code and
MyPy gives me more confidence in refactoring. Really solid stuff.</p>
<h2 id="elm">2. Elm</h2>
<p><a href="https://elm-lang.org/">Elm</a> is a purely functional
language with goals of no runtime errors, helpful compiler messages, and
a powerful type system. It takes some time to shift into a functional
mindset, but I&#x2019;ve used Elm for several weekend projects that spun into
week-long projects, and the compiler was a huge help. Coming back to
these projects a month later, I found it much, much easier to refactor
code, despite forgetting everything that I had written, because the
compiler had my back. JSON decoding is hard and I don&#x2019;t really
understand it, but everything else was slick.</p>
<p>I also loved not worrying about Webpack and Bable and JSX and
TypeScript and what-have-you because <code>elm make</code> just works.
Really nice, I strongly recommend trying it out over a weekend. The
community is definitely small&#x2014;I had to write a <a
href="https://github.com/samuelstevens/elm-csv">CSV parsing package</a>.
But Elm works so well that it was fun to write a CSV parsing package.
You read that correctly: I thought it was <em>fun</em>.</p>
<p>I think any web app that I work on that&#x2019;s not doing some crazy stuff
with animations or the Canvas or some brand new web tech will be written
in Elm. It&#x2019;s how I wrote my <a
href="https://samuelstevens.me/elm-quiet-hn/">Quiet HN clone</a>. It&#x2019;s
really good at making scalable single-page web apps.</p>
<h2 id="rust">3. Rust</h2>
<p><a href="https://github.com/samuelstevens/merge-attention">I recently
used</a> Rust to speed up some Python code using <a
href="https://github.com/PyO3/maturin">Maturin</a>. Learning Rust as a
just-in-time operation (time to learn enough about lifetimes to satisfy
<code>rustc</code>) was a good way for me to learn and led to a very,
very useful package. I rarely work on projects where performance is
critical throughout the application&#x2014;normally there are easily
identifiable &#x201C;hot-spots&#x201D; that I notice with a profiler. Those projects
are normally Python projects, and Rust and Maturing makes it really
simple to speed up hot spots until performance is at an acceptable
level. I used to use C for this sort of thing with <a
href="https://docs.python.org/3.9/library/ctypes.html#module-ctypes"><code>ctypes</code></a>,
but the Rust compiler gives me confidence in memory usage, the Rust
tooling is much better, and the Rust standard library and crate
ecosystem are great.</p>
<h1 id="other-languages-im-familiar-with-but-avoid">Other languages I&#x2019;m
familiar with but avoid</h1>
<p>These are other languages that I have used for projects in the past,
and would feel comfortable working with, but don&#x2019;t use unless there is a
good reason to (typically existing code is written in the language).</p>
<h2 id="go">4. Go</h2>
<p><a href="https://golang.org/">Go</a> is cool. The language itself is
quite simple, without a lot of extra syntax to learn. It&#x2019;s strongly
typed, which I&#x2019;ve realized is very important for writing <a
href="/writing/abstractions-and-types">readable, maintainable code</a>.
It has a garbage collector, so I can write code without having to think
about memory all the time. It has an autoformatter, the compiler is
aggressive in not letting me compile until I have higher quality code
(can&#x2019;t compile with an unused variable). Basically, Go is great for
working on large teams. Unfortunately, I don&#x2019;t do a lot of team projects
where we are writing a server-side application and maintaining the
application is absolutely critical. I think Go would have been a good
fit for <a href="https://salty.software/ticketbay">TicketBay</a>.</p>
<p><strong>Update June 3, 2020</strong></p>
<p>After building <a
href="/projects/img-alter"><code>img-alter</code></a> in Go, I think Go
is almost <em>too general</em> a language. If I want to make a webapp,
I&#x2019;d use static HTML with Typescript/React. If I wanted to make a mobile
app, I&#x2019;d use Typescript/React Native. If I wanted to do some data
analysis, I&#x2019;d use Python. If I wanted to do real low-level work (for
fun, I guess?), I&#x2019;d use C.</p>
<h2 id="typescript">5. TypeScript</h2>
<p><a href="https://www.typescriptlang.org/">TypeScript</a> is a typed
superset of JavaScript that compiles to plain JavaScript. Basically, you
add types to JavaScript so everyone knows what&#x2019;s going on, and so you
remove
<code>"TypeError: Cannot read property 'greeting' of undefined"</code>
errors right off the bat.</p>
<p>In addition to helping with type errors, TypeScript is amazingly
well-integrated with <a href="https://code.visualstudio.com/">VS
Code</a>, which is a text editor built on Electron that manages to
perform well and provide pseudo-IDE features that never feel
overbearing.</p>
<p>If you use VS Code already with JavaScript, give TypeScript a shot.
It&#x2019;s amazing how much of the code just falls in place without me reading
any API docs.</p>
<p>Anytime I start a project in JavaScript that&#x2019;s non-trivial, I always
start in TypeScript. It&#x2019;s just that good.</p>
<h2 id="c">6. C</h2>
<p>C is fun for me as a web apps guy because I understand what every
line is doing on a much lower level. It&#x2019;s very easy to reason about what
is happening on the machine, in a not-so-abstract realization. Compared
to JavaScript, I could tell you what every line is doing in terms of the
heap and stack. Sometimes that&#x2019;s really fun. Other times I need to get
work done and C isn&#x2019;t the solution. When it is, or when I have to use it
for school, I like it.</p>
<h2 id="javascript">7. JavaScript</h2>
<p>JavaScript lets you write code that runs in the browser. There are
other options (TypeScript, ClojureScript, WebAssembly), but for the most
part, you&#x2019;re just writing JavaScript.</p>
<p>Yeah it sucks. Yeah nothing makes sense. But ESLint and npm go the
distance when you have no other alternatives, and there are thousands of
tutorials and resources out there.</p>
<p><strong>Update April 21, 2020</strong></p>
<p>Since going through another Hackathon and building <a
href="https://github.com/samuelstevens/slow-youtube">Slow YouTube</a>
using TypeScript, I now firmly believe that JavaScript shouldn&#x2019;t be used
in any scenario where it&#x2019;s possible to use any other language.</p>
<h2 id="java">8. Java</h2>
<p>Java works everywhere. Everyone I know can read and write some Java.
It&#x2019;s strongly typed, compiled, not that slow now that the JVM is
optimized, yadda yadda.</p>
<p>It&#x2019;s a shame I have only memories of writing shitty Java for early
software classes, because I never want to do that again.</p>
<p>It&#x2019;s Java. I can fumble my way through it.</p>
<h2 id="c-1">9. C++</h2>
<p>I worked on <a href="https://powerbi.microsoft.com/en-us/">Power
BI</a> engine at Microsoft. It&#x2019;s a 100-million+ line C++ project. I
don&#x2019;t claim to be a C++ expert (does anyone?), but I have worked at it
enough to form a nascent opinion.</p>
<p>It&#x2019;s really really complicated, but those compiled binaries are
really fast. That is all.</p>
<p>More seriously, before starting a new project in C++, consider if you
could write most of it in C#/Java/Go/Python/something easy and just
write the slow parts in C++. Also consider Rust.</p>
<h1 id="languages-im-missing-that-i-wish-i-wasnt">Languages I&#x2019;m Missing
That I Wish I Wasn&#x2019;t</h1>
<ul>
<li>Lisp: I keep hearing that Lisp is the one true way. I just couldn&#x2019;t
figure it out fast enough to be useful. <strong>Update Feb 5, 2021: <a
href="/writing/lisp">I&#x2019;m working on fixing this</a>.</strong></li>
<li>Haskell: apparently a cool language that you don&#x2019;t need to know
entirely to be useful, but I don&#x2019;t think I write complicated enough
systems to need Haskell. Would it help me with smaller systems?</li>
<li>Erlang/Elixir: writing extremely fault-tolerant concurrent systems
sounds really cool, but I have no need for one.</li>
<li>Ruby: also apparently really easy to learn, but I have Python and
JavaScript. Where does Ruby fit in?</li>
<li>Odin, Zig, Scopes, D, Nim? Lots of low-level replacements for
C.</li>
</ul>
<p>You&#x2019;ll notice that most of the time I think I don&#x2019;t need any of these
languages because I don&#x2019;t have large enough problems to make it worth
it. <em>That scares me</em>, because I bet people who write in those
languages can&#x2019;t imagine a small enough project for it not to be worth
using, i.e., I should just learn those languages and use them for
everything already.</p>
<p>*terror that I&#x2019;m an average programmer increases*</p>
<h1 id="updates">Updates</h1>
<p><strong>Update January 5, 2021</strong></p>
<p>Worked with C++, Rust and Racket. Worked more with Elm and
Python.</p>
<p><strong>Update Jun 3, 2020</strong></p>
<p>After spending more time with Go, it feels too general.</p>
<p><strong>Update January 21, 2020</strong></p>
<p>Added Rust.</p>
<p>Please <a href="mailto:samuel.robert.stevens@gmail.com">email me</a>
if you have any comments or want to discuss further..</p>
      <hr />
      <p>[<a href="https://www.youtube-nocookie.com/embed/SHbS9tYFpcQ">Relevant link</a>] [<a href="https://github.com/samuelstevens/personal-website">Source</a>]</p>
      <p>Sam Stevens, 2022</p>
    </article>
  </main>
  <script src="/js/instantclick.min.js" data-no-instant></script>
  <script data-no-instant>
    InstantClick.init();
  </script>
  <style>
    
  </style>
</body>

</html>
